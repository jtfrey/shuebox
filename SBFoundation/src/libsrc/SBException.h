//
// SBFoundation : ObjC Class Library for Solaris
// SBException.h
//
// Support for exception handling within non-Apple Objective-C runtimes.  Concepts
// borrowed from myStep.
//
// Copyright (c) 2010
// University of Delaware
//
// $Id$
//

#import "SBString.h"
#include <setjmp.h>
#include <stdarg.h>

@class SBDictionary;

/*!
  @class SBException
  @discussion
    An SBException object wraps the information associated with an error condition.  Exceptions
    can be raised ("thrown" in some other languages):  execution immediately returns to the last
    exception block.  An exception block looks like this:
    
      TRY_BEGIN
          :
        code which could produce an exception
          :
      TRY_CATCH(anException)
          :
        code to handle (possibly re-throwing) whatever exception was produced
        the SBException instance that was thrown is accessible in "anException"
          :
      TRY_END
    
    Minimally, an SBException should have an identifier that tersely describes the error
    condition.  A more verbose description can be provided as the reason.  Finally, any
    additional information can be communicated back to exception handlers in the userInfo
    dictionary.
*/
@interface SBException : SBObject
{    
	SBString*     _identifier;
	SBString*     _reason;
	SBDictionary* _userInfo;
}

/*!
  @method exceptionWithIdentifier:reason:userInfo:
  @discussion
    Returns an autoreleased instance of SBException which is initialized with the provided
    identifier, reason, and userInfo.  This method does not actually raise the exception!
*/
+ (SBException*) exceptionWithIdentifier:(SBString*)identifier reason:(SBString*)reason userInfo:(SBDictionary*)userInfo;
/*!
  @method raise:format:...
  @discussion
    Raise an exception with the given identifier and a reason constructed by a printf-like
    format string and arguments.  The format and arguments are used with SBString's stringWithFormat:arguments:
    method to produce the reason.  The resulting SBException object is immediately raised.
*/
+ (void) raise:(SBString*)identifier format:(const char*) format, ...;
/*!
  @method raise:format:arguments:
  @discussion
    Raise an exception with the given identifier and a reason constructed by a printf-like
    format string and arguments.  The format and arguments are used with SBString's stringWithFormat:arguments:
    method to produce the reason.  The resulting SBException object is immediately raised.
*/
+ (void) raise:(SBString*)identifier format:(const char*) format arguments:(va_list)argList;
/*!
  @method initWithIdentifier:reason:userInfo:
  @discussion
    Initializes a newly-allocated instance of SBException.
*/
- (id) initWithIdentifier:(SBString*)identifier reason:(SBString*)reason userInfo:(SBDictionary*)userInfo;
/*!
  @method identifier
  @discussion
    Returns the receiver's exception identifier.
*/
- (SBString*) identifier;
/*!
  @method reason
  @discussion
    Returns the receiver's reason string.
*/
- (SBString*) reason;
/*!
  @method userInfo
  @discussion
    Returns the receiver's userInfo dictionary.
*/
- (SBDictionary*) userInfo;
/*!
  @method raise
  @discussion
    Raise the receiver.  Program execution jumps back to the last established exception block
    and resumes in the TRY_CATCH section.
*/
- (void) raise;

@end

/*!
  @const SBGenericException
  @discussion
    String constant that is used to identify non-specific exceptions.
*/
extern SBString* SBGenericException;
/*!
  @const SBAutoreleaseException
  @discussion
    String constant that is used to identify exceptions generated by the autorelease sub-system.
*/
extern SBString* SBAutoreleaseException;


/*!
  @typedef SBExceptionState
  @discussion
    Consider this a private data structure!  Each exception block places one of these on
    the stack and chains it to the previously-established exception blocks.
*/
typedef struct _SBExceptionState {
  jmp_buf                     origin; /* place to which execution will return on longjmp() */
  struct _SBExceptionState*   link;
  SBException*                exception;
} SBExceptionState;

/*!
  @typedef SBUncaughtExceptionHandler
  @discussion
    Prototype for a function which handles exceptions raised outside the
    scope of any exception blocks.
*/
typedef void SBUncaughtExceptionHandler(SBException* exception);

/*!
  @const _SBUncaughtExceptionHandler
  @discussion
    Pointer to the function which currently handles uncaught exceptions
    in the runtime.
*/
extern SBUncaughtExceptionHandler* _SBUncaughtExceptionHandler;
#define SBGetUncaughtExceptionHandler() _SBUncaughtExceptionHandler
#define SBSetUncaughtExceptionHandler(proc) \
			(_SBUncaughtExceptionHandler = (proc))

/*!
  @function _SBPushExceptionState
  @discussion
    Private to the framework, do not call directly!
*/
extern void _SBPushExceptionState(SBExceptionState* newState);
/*!
  @function _SBPopExceptionState
  @discussion
    Private to the framework, do not call directly!
*/
extern void _SBPopExceptionState(void);

/*!
  @defined TRY_BEGIN
  @discussion
    Denotes the start of an exception block.  Never explicitly return()
    inside an exception block -- see the TRY_RETURN_VALUE and TRY_RETURN
    macros!
*/
#define TRY_BEGIN \
{ \
  SBExceptionState  SBLocalExceptionState; \
  _SBPushExceptionState(&SBLocalExceptionState); \
  if( ! setjmp(SBLocalExceptionState.origin) ) {

/*!
  @defined TRY_CATCH
  @discussion
    Denotes the exception-handling code for an exception block.  Takes a single
    argument:  the name of the local variable which should hold the raised
    SBException.
*/
#define TRY_CATCH(SBEXCEPTION_VAR) \
    _SBPopExceptionState(); \
  } else { \
    SBException*  SBEXCEPTION_VAR = SBLocalExceptionState.exception;

/*!
  @defined TRY_END
  @discussion
    Denotes the end of an exception block.
*/
#define TRY_END \
  } \
}

/*!
  @defined TRY_RETURN_VALUE
  @discussion
    Use this macro inside an exception block to return a value from the function.
    The exception state must be cleaned-up before exiting.  Takes two arguments:
    the value to return and its type.  E.g.
    
      TRY_RETURN_VALUE(@"Failed!", SBString*);
*/
#define TRY_RETURN_VALUE(SBEXCEPTION_VALUE, SBEXCEPTION_VALUETYPE) \
do { \
  SBEXCEPTION_VALUETYPE rc = (SBEXCEPTION_VALUE);	\
  _SBPopExceptionState();	\
  return (rc); \
} while (0)

/*!
  @defined TRY_RETURN
  @discussion
    Use this macro inside an exception block to return from the void-typed function.
    The exception state must be cleaned-up before exiting.
*/
#define TRY_RETURN \
do { \
  _SBPopExceptionState();	\
  return; \
} while (0)
